using Content.Client.Audio;
using Content.Client.UI.StyleSheets.Default;
using Content.Shared.Input;
using Robust.Client.AutoGenerated;
using Robust.Client.Input;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Linq;
using System.Text.RegularExpressions;
using static Robust.Client.Input.Keyboard;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.OptionsMenu
{
	[GenerateTypedNameReferences]
	public sealed partial class HotkeyTab : Control
	{
		[Dependency] private readonly IInputManager _inputManager = default!;
		[Dependency] private readonly IUserInterfaceManager _uiManager = default!;

		private readonly List<Action> _keybindResets = new();

		private readonly List<Key> _heldKeys = new();

		private record HotKeyBoxEntry(BoundKeyFunction Function, HotKeyBox HotkeyBox);
		private readonly List<HotKeyBoxEntry> _hoykeyBoxes = new();

		private bool _currentlyRebinding = false;
		private BoundKeyFunction _rebindingFunction;

		private const string FunctionUnboundLabel = "Unbound";

		public HotkeyTab()
		{
			RobustXamlLoader.Load(this);
			IoCManager.InjectDependencies(this);

			foreach (var hotkeySet in GetHotkeySets())
			{
				KeybindsContainer.AddChild(new Label
				{ 
					Text = hotkeySet.CategoryName, StyleClasses = { DefaultContentStyle.StyleClassHeaderFont }
				});

				foreach (var function in hotkeySet.Functions)
				{
					var hotkeyBox = new HotKeyBox(FunctionNameToString(function.FunctionName));
					_hoykeyBoxes.Add(new HotKeyBoxEntry(function, hotkeyBox));
					KeybindsContainer.AddChild(hotkeyBox);

					hotkeyBox.ResetButton.OnButtonUp += _ => ResetKeybind(function);
					hotkeyBox.RebindButton.OnButtonUp += _ => StartRebinding(function);
					hotkeyBox.ClearButton.OnButtonUp += _ => ClearKeybind(function);
				}
			}
			UpdateButtons();
			ResetAllButton.OnButtonUp += _ => AllHotkeys().ToList()
				.ForEach(function => ResetKeybind(function));

			string FunctionNameToString(string str)
			{
				var regex = new Regex("(?<!^)([A-Z][a-z]|(?<=[a-z])[A-Z])", RegexOptions.Compiled);
				return regex.Replace(str, " $1");
			}
		}

		private void ResetKeybind(BoundKeyFunction function)
		{
			//Reseting the keybind is defered to the next frame
			//Removing a keybind in the middle of InputManager handling a key input causes a crash
			_keybindResets.Add(() =>
			{
				_inputManager.ResetBindingsFor(function);
				_inputManager.SaveToUserData();
				UpdateButtons();
			});
		}

		private void ClearKeybind(BoundKeyFunction function)
		{
			if (!_inputManager.TryGetKeyBinding(function, out var binding))
				return;

			//Reseting the keybind is defered to the next frame
			//Removing a keybind in the middle of InputManager handling a key input causes a crash
			_keybindResets.Add(() =>
			{
				_inputManager.RemoveBinding(binding);
				_inputManager.SaveToUserData();
				UpdateButtons();
			});
		}

		private void UpdateButtons()
		{
			foreach (var hotkeyBoxEntry in _hoykeyBoxes)
			{
				var function = hotkeyBoxEntry.Function;
				var hotkeyBox = hotkeyBoxEntry.HotkeyBox;

				hotkeyBox.RebindButton.Disabled = _currentlyRebinding;

				_inputManager.TryGetKeyBinding(function, out var currentBind);
				var bindText = currentBind is not null ? currentBind.GetKeyString() : FunctionUnboundLabel;
				hotkeyBox.RebindButton.Text = _rebindingFunction == function ?
					"Rebinding..." : bindText;

				hotkeyBox.ResetButton.Disabled = !_inputManager.IsKeyFunctionModified(function);
				hotkeyBox.ClearButton.Disabled = !_inputManager.TryGetKeyBinding(function, out _);
			}

			var changedKeys = _hoykeyBoxes.Select(i => (i, _inputManager.IsKeyFunctionModified(i.Function))).Where(i => i.Item2);
			ResetAllButton.Disabled = !_hoykeyBoxes.Select(i => _inputManager.IsKeyFunctionModified(i.Function))
				.Contains(true);
		}

		private void StartRebinding(BoundKeyFunction function)
		{
			_currentlyRebinding = true;
			_rebindingFunction = function;

			UpdateButtons();

			KeyEventAction handler = (_, _) => { };
			handler = (keyEvent, type) => InterceptInput(keyEvent, type, handler, function);
			_inputManager.FirstChanceOnKeyEvent += handler;

			void InterceptInput(KeyEventArgs keyEvent, KeyEventType type, KeyEventAction handler, BoundKeyFunction function)
			{
				if (type == KeyEventType.Down)
				{
					_heldKeys.Add(keyEvent.Key);
					return;
				}
				else if (type == KeyEventType.Repeat)
				{
					return;
				}
				if (!_heldKeys.Any())
				{
					return;
				}

				RebindHotkey(function, _heldKeys);

				_inputManager.FirstChanceOnKeyEvent -= handler;
				_heldKeys.Clear();
				_currentlyRebinding = false;
				_rebindingFunction = default;
				UpdateButtons();

				_uiManager.ClickSound();
			}
		}

		private IKeyBinding RebindHotkey(BoundKeyFunction function, List<Key> newKeys)
		{
			_inputManager.TryGetKeyBinding(function, out var currentBind);

			newKeys.TryGetValue(0, out var primaryKey);
			newKeys.TryGetValue(1, out var mod1);
			newKeys.TryGetValue(2, out var mod2);
			newKeys.TryGetValue(3, out var mod3);

			var keysSame =
				currentBind is not null &&
				primaryKey == currentBind.BaseKey &&
				mod1 == currentBind.Mod1 &&
				mod2 == currentBind.Mod2 &&
				mod3 == currentBind.Mod3;

			var newBind = new KeyBindingRegistration
			{
				Function = function,
				BaseKey = primaryKey,
				Mod1 = mod1,
				Mod2 = mod2,
				Mod3 = mod3,
				Priority = 0,
				Type = KeyFunctionToBindType(function), //todo 
				CanFocus = false, //todo how to make sure this is enabled for ui clicks
				CanRepeat = false,  //todo 
			};
			if (currentBind is not null)
				_inputManager.RemoveBinding(currentBind, !keysSame);
			var newKeyBind = _inputManager.RegisterBinding(newBind, !keysSame);
			_inputManager.SaveToUserData();
			return newKeyBind;

			KeyBindingType KeyFunctionToBindType(BoundKeyFunction function)
			{
				return function switch
				{
					_ => KeyBindingType.State //default them all to state for now
				};
			}
		}

		protected override void FrameUpdate(FrameEventArgs args)
		{
			base.FrameUpdate(args);

			foreach (var command in _keybindResets)
			{
				command();
			}
			_keybindResets.Clear();
		}

		private sealed class HotKeyBox : Control
		{
			public readonly Button RebindButton;
			public readonly Button ResetButton;
			public readonly Button ClearButton;

			public HotKeyBox(string functionName)
			{
				IoCManager.InjectDependencies(this);

				var functionLabel = new Label
				{
					Text = functionName,
					MinWidth = 300f,
				};
				RebindButton = new Button { MinWidth = 150f };
				ResetButton = new Button { Text = "Reset" };
				ClearButton = new Button { Text = "Clear" };
				AddChild(new BoxContainer
				{
					Orientation = LayoutOrientation.Horizontal,
					Children =
					{
						functionLabel,
						RebindButton,
						ResetButton,
						ClearButton,
					}
				});
			}
		}

		private List<HotkeySet> GetHotkeySets()
		{
			var movementKeys = new HotkeySet("Movement",
				new List<BoundKeyFunction>
				{
					EngineKeyFunctions.MoveUp,
					EngineKeyFunctions.MoveDown,
					EngineKeyFunctions.MoveLeft,
					EngineKeyFunctions.MoveRight,
				});
			var mappingKeys = new HotkeySet("Mapping",
				new List<BoundKeyFunction>
				{
					ContentKeyFunctions.OpenMappingCommandWindow,
					ContentKeyFunctions.OpenEntitySpawnWindow,
					ContentKeyFunctions.OpenTileSpawnWindow,
					EngineKeyFunctions.EditorPlaceObject,
					EngineKeyFunctions.EditorCancelPlace,
					EngineKeyFunctions.EditorGridPlace,
					EngineKeyFunctions.EditorLinePlace,
					EngineKeyFunctions.EditorRotateObject,
				});
			var devKeys = new HotkeySet("Development",
				new List<BoundKeyFunction>
				{
					EngineKeyFunctions.ShowDebugConsole,
					EngineKeyFunctions.ShowDebugMonitors,
					EngineKeyFunctions.HideUI,
				});

			return new List<HotkeySet>
			{
				movementKeys,
				mappingKeys,
				devKeys,
			};
		}

		private IEnumerable<BoundKeyFunction> AllHotkeys() => GetHotkeySets().SelectMany(set => set.Functions);
		private sealed class HotkeySet
		{
			public string CategoryName { get; private set; }

			public List<BoundKeyFunction> Functions { get; private set; }

			public HotkeySet(string categoryName, List<BoundKeyFunction> functions)
			{
				CategoryName = categoryName;
				Functions = functions;
			}
		}
	}
}

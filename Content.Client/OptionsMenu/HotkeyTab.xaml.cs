using Content.Client.Audio;
using Content.Client.UI.StyleSheets.Default;
using Content.Shared.Input;
using Robust.Client.AutoGenerated;
using Robust.Client.Input;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using System.Linq;
using System.Text.RegularExpressions;
using static Robust.Client.Input.Keyboard;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.OptionsMenu
{
	[GenerateTypedNameReferences]
	public sealed partial class HotkeyTab : Control
	{
		[Dependency] private readonly IInputManager _inputManager = default!;
		[Dependency] private readonly IUserInterfaceManager _uiManager = default!;

		private readonly List<Action> _keybindResets = new();

		private readonly List<Key> _heldKeys = new();

		private readonly List<HotKeyBox> _hoykeyBoxes = new();

		private bool _currentlyRebinding = false;
		private BoundKeyFunction _rebindingFunction;

		private const string FunctionUnboundLabel = "Unbound";

		public HotkeyTab()
		{
			RobustXamlLoader.Load(this);
			IoCManager.InjectDependencies(this);

			foreach (var hotkeySet in GetHotkeySets())
			{
				KeybindsContainer.AddChild(new Label
					{ 
						Text = hotkeySet.CategoryName, StyleClasses = { DefaultContentStyle.StyleClassHeaderFont }
					});

				foreach (var function in hotkeySet.Functions)
				{
					AddHotkeyBox(function);
				}
			}
			UpdateAllHotkeyBoxes();
			UpdateResetAllButton();
			ResetAllButton.OnButtonUp += _ => ResetAllKeybinds();

			void AddHotkeyBox(BoundKeyFunction function)
			{
				var hotkeyBox = new HotKeyBox(function);
				_hoykeyBoxes.Add(hotkeyBox);
				KeybindsContainer.AddChild(hotkeyBox);

				hotkeyBox.ResetButton.OnButtonUp += _ => ResetKeybind(hotkeyBox);
				hotkeyBox.RebindButton.OnButtonUp += _ => StartRebinding(hotkeyBox);
				hotkeyBox.ClearButton.OnButtonUp += _ => ClearKeybind(hotkeyBox);
			}
		}

		private void ResetAllKeybinds()
		{
			foreach (var hotkeyBox in _hoykeyBoxes)
			{
				ResetKeybind(hotkeyBox);
			}
		}

		private void ResetKeybind(HotKeyBox hotkeyBox)
		{
			//Reseting the keybind is defered to the next frame
			//Removing a keybind in the middle of InputManager handling a key input causes a crash
			_keybindResets.Add(() =>
			{
				_inputManager.ResetBindingsFor(hotkeyBox.Function);
				_inputManager.SaveToUserData();
				UpdateHotkeyBox(hotkeyBox);
			});
		}

		private void ClearKeybind(HotKeyBox hotkeyBox)
		{
			if (!_inputManager.TryGetKeyBinding(hotkeyBox.Function, out var binding))
				return;

			//Reseting the keybind is defered to the next frame
			//Removing a keybind in the middle of InputManager handling a key input causes a crash
			_keybindResets.Add(() =>
			{
				_inputManager.RemoveBinding(binding);
				_inputManager.SaveToUserData();
				UpdateHotkeyBox(hotkeyBox);
			});
		}

		private void UpdateAllHotkeyBoxes()
		{
			foreach (var hotkeyBox in _hoykeyBoxes)
			{
				UpdateHotkeyBox(hotkeyBox);
			}
		}

		private void UpdateHotkeyBox(HotKeyBox hotkeyBox)
		{
			hotkeyBox.RebindButton.Disabled = _currentlyRebinding;

			_inputManager.TryGetKeyBinding(hotkeyBox.Function, out var currentBind);
			var bindText = currentBind is not null ? currentBind.GetKeyString() : FunctionUnboundLabel;
			hotkeyBox.RebindButton.Text = _rebindingFunction == hotkeyBox.Function ?
				"Rebinding..." : bindText;

			hotkeyBox.ResetButton.Disabled = !_inputManager.IsKeyFunctionModified(hotkeyBox.Function);
			hotkeyBox.ClearButton.Disabled = !_inputManager.TryGetKeyBinding(hotkeyBox.Function, out _);

			_inputManager.TryGetKeyBinding(hotkeyBox.Function, out var bind);
		}

		private void UpdateResetAllButton()
		{
			var modifiedKeys = _hoykeyBoxes.Select(i => (i.Function, _inputManager.IsKeyFunctionModified(i.Function)))
				.Where(i => i.Item2);
			ResetAllButton.Disabled = !modifiedKeys.Any();
		}

		private void StartRebinding(HotKeyBox rebindingHotkeyBox)
		{
			_currentlyRebinding = true;
			_rebindingFunction = rebindingHotkeyBox.Function;

			UpdateAllHotkeyBoxes();

			KeyEventAction handler = (_, _) => { };
			handler = (keyEvent, type) => InterceptInput(keyEvent, type, handler, rebindingHotkeyBox);
			_inputManager.FirstChanceOnKeyEvent += handler;
		}

		private void InterceptInput(KeyEventArgs keyEvent, KeyEventType type, KeyEventAction handler, HotKeyBox rebindingHotkeyBox)
		{
			if (type == KeyEventType.Down)
			{
				_heldKeys.Add(keyEvent.Key);
				return;
			}
			else if (type == KeyEventType.Repeat)
			{
				return;
			}
			if (!_heldKeys.Any())
			{
				return;
			}

			RebindHotkey(rebindingHotkeyBox.Function, _heldKeys);

			_inputManager.FirstChanceOnKeyEvent -= handler;
			_heldKeys.Clear();
			_currentlyRebinding = false;
			_rebindingFunction = default;
			UpdateAllHotkeyBoxes();

			_uiManager.ClickSound();
		}

		private IKeyBinding RebindHotkey(BoundKeyFunction function, List<Key> newKeys)
		{
			_inputManager.TryGetKeyBinding(function, out var currentBind);

			newKeys.TryGetValue(0, out var primaryKey);
			newKeys.TryGetValue(1, out var mod1);
			newKeys.TryGetValue(2, out var mod2);
			newKeys.TryGetValue(3, out var mod3);

			var newBind = new KeyBindingRegistration
			{
				Function = function,
				BaseKey = primaryKey,
				Mod1 = mod1,
				Mod2 = mod2,
				Mod3 = mod3,
				Priority = 0,
				Type = KeyFunctionToBindType(function), //todo 
				CanFocus = false, //todo how to make sure this is enabled for ui clicks
				CanRepeat = false,  //todo 
			};
			if (currentBind is not null)
				_inputManager.RemoveBinding(currentBind);
			var newKeyBind = _inputManager.RegisterBinding(newBind);
			_inputManager.SaveToUserData();
			UpdateResetAllButton();
			return newKeyBind;

			KeyBindingType KeyFunctionToBindType(BoundKeyFunction function)
			{
				return function switch
				{
					_ => KeyBindingType.State //default them all to state for now
				};
			}
		}

		protected override void FrameUpdate(FrameEventArgs args)
		{
			base.FrameUpdate(args);

			foreach (var command in _keybindResets)
			{
				command();
				UpdateResetAllButton();
			}
			_keybindResets.Clear();
		}

		private sealed class HotKeyBox : Control
		{
			public readonly Button RebindButton;
			public readonly Button ResetButton;
			public readonly Button ClearButton;
			public readonly BoundKeyFunction Function;

			public HotKeyBox(BoundKeyFunction function)
			{
				IoCManager.InjectDependencies(this);
				Function = function;

				var functionLabel = new Label
				{
					Text = FunctionNameToString(Function.FunctionName),
					MinWidth = 300f,
				};
				RebindButton = new Button { MinWidth = 150f };
				ResetButton = new Button { Text = "Reset" };
				ClearButton = new Button { Text = "Clear" };
				AddChild(new BoxContainer
				{
					Orientation = LayoutOrientation.Horizontal,
					Children =
					{
						functionLabel,
						RebindButton,
						ResetButton,
						ClearButton,
					}
				});

				string FunctionNameToString(string str)
				{
					var regex = new Regex("(?<!^)([A-Z][a-z]|(?<=[a-z])[A-Z])", RegexOptions.Compiled);
					return regex.Replace(str, " $1");

				} 
			}
		}

		private List<HotkeySet> GetHotkeySets()
		{
			var movementKeys = new HotkeySet("Movement",
				new List<BoundKeyFunction>
				{
					EngineKeyFunctions.MoveUp,
					EngineKeyFunctions.MoveDown,
					EngineKeyFunctions.MoveLeft,
					EngineKeyFunctions.MoveRight,
				});
			var mappingKeys = new HotkeySet("Mapping",
				new List<BoundKeyFunction>
				{
					ContentKeyFunctions.OpenMappingCommandWindow,
					ContentKeyFunctions.OpenEntitySpawnWindow,
					ContentKeyFunctions.OpenTileSpawnWindow,
					EngineKeyFunctions.EditorPlaceObject,
					EngineKeyFunctions.EditorCancelPlace,
					EngineKeyFunctions.EditorGridPlace,
					EngineKeyFunctions.EditorLinePlace,
					EngineKeyFunctions.EditorRotateObject,
				});
			var devKeys = new HotkeySet("Development",
				new List<BoundKeyFunction>
				{
					EngineKeyFunctions.ShowDebugConsole,
					EngineKeyFunctions.ShowDebugMonitors,
					EngineKeyFunctions.HideUI,
				});

			return new List<HotkeySet>
			{
				movementKeys,
				mappingKeys,
				devKeys,
			};
		}

		private sealed class HotkeySet
		{
			public string CategoryName { get; private set; }

			public List<BoundKeyFunction> Functions { get; private set; }

			public HotkeySet(string categoryName, List<BoundKeyFunction> functions)
			{
				CategoryName = categoryName;
				Functions = functions;
			}
		}
	}
}
